# -*- coding: utf-8 -*-
##Given a 2D array of digits, try to find the occurrence of a given 2D pattern of digits. For example, consider the following 2D matrix:
##
##1234567890  
##0987654321  
##1111111111  
##1111111111  
##2222222222  
##Assume we need to look for the following 2D pattern:
##
##876543  
##111111  
##111111
##If we scan through the original array, we observe that the 2D pattern begins at the second row and the third column of the larger grid (the 88 in the second row and third column of the larger grid is the top-left corner of the pattern we are searching for).
##
##So, a 2D pattern of PP digits is said to be present in a larger grid GG, if the latter contains a contiguous, rectangular 2D grid of digits matching with the pattern PP, similar to the example shown above.
##
##Input Format 
##The first line contains an integer, TT, which is the number of test cases. TT test cases follow, each having a structure as described below: 
##The first line contains two space-separated integers, RR and CC, indicating the number of rows and columns in the grid GG, respectively. 
##This is followed by RR lines, each with a string of CC digits, which represent the grid GG. 
##The following line contains two space-separated integers, rr and cc, indicating the number of rows and columns in the pattern grid PP. 
##This is followed by rr lines, each with a string of cc digits, which represent the pattern PP.
##
##Constraints 
##1≤T≤51≤T≤5 
##1≤R,r,C,c≤10001≤R,r,C,c≤1000 
##1≤r≤R1≤r≤R 
##1≤c≤C1≤c≤C
##Test Case Generation 
##Each individual test case has been generated by first specifying the size (RR and CC) of the large 2D matrix, and then randomly generating the digits in it. A limited number of digits in the larger matrix may be changed by the problem setter (no more than 5% of the total number of digits in the matrix). So the larger 2D matrix is almost-random. The pattern matrix has been manually-curated by the problem setter.
##
##Output Format 
##Display 'YES' or 'NO', depending on whether (or not) you find that the larger grid GG contains the rectangular pattern PP. The evaluation will be case sensitive.
##
##Sample Input
##
##2
##10 10
##7283455864
##6731158619
##8988242643
##3830589324
##2229505813
##5633845374
##6473530293
##7053106601
##0834282956
##4607924137
##3 4
##9505
##3845
##3530
##15 15
##400453592126560
##114213133098692
##474386082879648
##522356951189169
##887109450487496
##252802633388782
##502771484966748
##075975207693780
##511799789562806
##404007454272504
##549043809916080
##962410809534811
##445893523733475
##768705303214174
##650629270887160
##2 2
##99
##99
##Sample Output
##
##YES
##NO
##Explanation
##
##The first test in the input file is:
##
##10 10
##7283455864
##6731158619
##8988242643
##3830589324
##2229505813
##5633845374
##6473530293
##7053106601
##0834282956
##4607924137
##3 4
##9505
##3845
##3530
##As one may see, the given 2D grid is indeed present in the larger grid, as marked in bold below.
##
##7283455864  
##6731158619  
##8988242643  
##3830589324  
##2229505813  
##5633845374  
##6473530293  
##7053106601  
##0834282956  
##4607924137  
##The second test in the input file is:
##
##15 15
##400453592126560
##114213133098692
##474386082879648
##522356951189169
##887109450487496
##252802633388782
##502771484966748
##075975207693780
##511799789562806
##404007454272504
##549043809916080
##962410809534811
##445893523733475
##768705303214174
##650629270887160
##2 2
##99
##99
##The search pattern is:
##
##99
##99
##This cannot be found in the larger grid.

The following code works as expected for the given problem. That is, this will search for all the occurances of substring in each string. The following code works for input:
1
5 15
111111111111111
111111111111111
111111011111111
111111111111111
111111111111111
3 5
11111
11111
11110

#!/bin/python

import sys
import re

def cond_check(grid_row, grid_col, pat_row, pat_col, grid_val, pat_val):
    out = 'False'
    ind_mat = []
    pat = '(?=' + pat_val[0] + ')'
    for i, each in enumerate(grid_val):
        if grid_row - i >= pat_row:
            for m in re.finditer(pat, each):
                ind_mat.append((i, m.start()))
    for each in ind_mat:
        x = 0
        tot = ''
        while x < pat_row:
            tot = tot + grid_val[each[0]+x][each[1]:][:pat_col]
            x = x + 1
        if tot == ''.join(pat_val):
            out = 'True'
            return out
    return out

test_case = int(raw_input())
for tc in range(test_case):
    grid_row,grid_col = map(int, raw_input().split())
    grid_val = [raw_input() for i in range(grid_row)]
    pat_row, pat_col = map(int, raw_input().split())
    pat_val = [raw_input() for i in range(pat_row)]
    out = cond_check(grid_row, grid_col, pat_row, pat_col, grid_val, pat_val)
    if out == 'True':
        print "YES"
    else:
        print "NO"



The following code works,if finding only first instance of the substring is enough. i.e, the following code returns incorrect output, if there are more than one occurance of the substring in a string:
1
5 15
111111111111111
111111111111111
111111011111111
111111111111111
111111111111111
3 5
11111
11111
11110

#!/bin/python

import sys

def cond_check(grid_row,grid_col,pat_row,pat_col, grid_val, pat_val):
    out = 'False'
    print grid_val
    print pat_val
    #ind_mat = [(i, each.index(pat_val[0])) for i,each in enumerate(grid_val) if pat_val[0] in each and grid_row - i >= pat_row]
    print ind_mat
    for each in ind_mat:
        x = 0
        tot = ''
        while x < pat_row:
            tot = tot + grid_val[each[0]+x][each[1]:][:pat_col]
            x = x + 1
        if tot == ''.join(pat_val):
            out = 'True'
            return out
    return out

test_case = int(raw_input())
for tc in range(test_case):
    grid_row,grid_col = map(int, raw_input().split())
    grid_val = [raw_input() for i in range(grid_row)]
    pat_row, pat_col = map(int, raw_input().split())
    pat_val = [raw_input() for i in range(pat_row)]
    out = cond_check(grid_row,grid_col,pat_row,pat_col, grid_val, pat_val)
    if out == 'True':
        print "YES"
    else:
        print "NO"
